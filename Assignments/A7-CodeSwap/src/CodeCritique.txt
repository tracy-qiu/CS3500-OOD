After reviewing our assigned group’s code, the flexibility of some of their interfaces was somewhat
limited. For example, the BasicImageProcessor interface had limited flexibility because it would
need to be edited in order to implement new functionality. The methods for greyscale, brighten and
flip were located directly with the GridPixelImage class (their implementation of an image).
This is a slight design flaw that could be remedied by adding an ImageProcessCommand interface in
which subsequent classes (function objects) that implement this interface contain the functionality
for these methods. As a result, new functionality could be added by simply creating a new function
object. Additionally, the load and save methods are located in the model. This is not very flexible
because the interface/classes will have to be edited if you want to load/save a new image type.
Again, this could be remedied by having function objects that implement an ImageProcessCommand
interface.

When considering their overall implementation, our assigned group’s code was very strong.
In terms of its strengths, they had a well designed GUI view that was extremely user-friendly.
The layout was very self-explanatory and the user would not need to see the code in order to
understand how to use the program. The histogram and the various color channels of the image were
properly displayed. The program also allowed the option to scroll if the image was bigger than the
image panel. Additionally, using the program via the command line/terminal was also very intuitive.
The group displayed messages that guided the user through using the actual program, limiting
confusion. The program also has sufficient error handling for user inputs specifically for the
terminal (incorrect user inputs will not crash the program). The group also heavily abstracted
their overall code, including the buttons in the GUI, the function object commands for matrix
and filter functionality and their controller tests. Overall, they had great structure to their
code that clearly defined roles of the model, view and controller. There was no overlap between
the functionality of these classes.

In terms of weaknesses, the group’s code lacked function objects for the functionality specified
in Assignment 4, limiting design of future functionality. As a result, in their controller
commands, they are directly calling functionality in the model to alter the images, rather
than having this functionality contained in function objects (greyscale, brighten, flip).
Additionally, in order to initiate function objects for color transformation (matrix) and
filtering functionality, they are reliant on calling methods in the GridPixelImageClass.
The commands in the controller are void methods, which call  methods in the GridPixelImageClass
that then return a new altered image. These controller commands should return the new image
themselves rather than being void, in order to avoid having functionality in the image
implementation class. Finally, the code does not have error handling for the GUI, and
the program will crash if there is an invalid input for brighten, mosaic, etc.

When completing this assignment, their code was very convenient to use. It was fairly easy to add
functionality due to the extensive abstraction of program functionality. Other than changing the
GridPixelImage interface (didn’t have function objects in the model for basic functionality, only
matrixify and filterify), we were able to successfully use all other classes and interfaces to add
additional functionality. The code was well documented and the README and USEME were thorough, which
helped us better understand their design and implementation. All javadocs were properly written
explaining the use of each interface, class and method. We did not need to request this group to
make any changes to their code.


